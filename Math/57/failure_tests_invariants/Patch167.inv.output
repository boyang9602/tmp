===========================================================================
org.apache.commons.math.stat.clustering.Cluster:::CLASS
===========================================================================
org.apache.commons.math.stat.clustering.Cluster:::OBJECT
this.points[] elements != null
this.points[].getClass().getName() elements == org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest.CloseIntegerPoint.class
this.points.getClass().getName() == java.util.ArrayList.class
this.center has only one value
this.center.getClass().getName() == org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest$CloseIntegerPoint.class
===========================================================================
org.apache.commons.math.stat.clustering.Cluster.Cluster(org.apache.commons.math.stat.clustering.Clusterable):::ENTER
center has only one value
center.getClass().getName() == org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest$CloseIntegerPoint.class
===========================================================================
org.apache.commons.math.stat.clustering.Cluster.Cluster(org.apache.commons.math.stat.clustering.Clusterable):::EXIT
this.points[] == []
this.points[].getClass().getName() == []
===========================================================================
org.apache.commons.math.stat.clustering.Cluster.addPoint(org.apache.commons.math.stat.clustering.Clusterable):::ENTER
this has only one value
this.points has only one value
this.points[] elements has only one value
point.getClass().getName() == org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest$CloseIntegerPoint.class
===========================================================================
org.apache.commons.math.stat.clustering.Cluster.addPoint(org.apache.commons.math.stat.clustering.Clusterable):::EXIT
this.points == orig(this.points)
this.points.getClass().getName() == orig(this.points.getClass().getName())
this.center == orig(this.center)
this.center.getClass().getName() == orig(this.center.getClass().getName())
size(this.points[])-1 == orig(size(this.points[]))
this.points has only one value
===========================================================================
org.apache.commons.math.stat.clustering.Cluster.getCenter():::ENTER
===========================================================================
org.apache.commons.math.stat.clustering.Cluster.getCenter():::EXIT
this.points == orig(this.points)
this.points[] == orig(this.points[])
this.points.getClass().getName() == orig(this.points.getClass().getName())
this.center == orig(this.center)
this.center.getClass().getName() == orig(this.center.getClass().getName())
return has only one value
return.getClass().getName() == org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest$CloseIntegerPoint.class
===========================================================================
org.apache.commons.math.stat.clustering.EuclideanIntegerPoint:::CLASS
===========================================================================
org.apache.commons.math.stat.clustering.EuclideanIntegerPoint:::OBJECT
this.point[] elements one of { 0, 1 }
this.point[] one of { [0], [1] }
size(this.point[]) == 1
===========================================================================
org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.EuclideanIntegerPoint(int[]):::ENTER
point[] elements one of { 0, 1 }
point[] one of { [0], [1] }
size(point[]) == 1
===========================================================================
org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.EuclideanIntegerPoint(int[]):::EXIT
point[] == orig(point[])
point[] elements one of { 0, 1 }
point[] one of { [0], [1] }
===========================================================================
org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.distanceFrom(org.apache.commons.math.stat.clustering.EuclideanIntegerPoint):::ENTER
p has only one value
p.point has only one value
p.point[] == [0]
p.point[] elements == 0
size(p.point[]) == 1
===========================================================================
org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.distanceFrom(org.apache.commons.math.stat.clustering.EuclideanIntegerPoint):::EXIT
this.point == orig(this.point)
this.point[] == orig(this.point[])
p.point == orig(p.point)
p.point[] == orig(p.point[])
p.point has only one value
p.point[] == [0]
p.point[] elements == 0
return one of { 0.0, 1.0 }
size(p.point[]) == 1
===========================================================================
org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.equals(java.lang.Object):::ENTER
this has only one value
this.point has only one value
this.point[] == [0]
this.point[] elements == 0
other has only one value
other.getClass().getName() == org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.class
===========================================================================
org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.equals(java.lang.Object):::EXIT91
===========================================================================
org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.equals(java.lang.Object):::EXIT91;condition="return == true"
===========================================================================
org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.equals(java.lang.Object):::EXIT
this.point == orig(this.point)
this.point[] == orig(this.point[])
this.point has only one value
this.point[] == [0]
this.point[] elements == 0
return == true
===========================================================================
org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.equals(java.lang.Object):::EXIT;condition="return == true"
===========================================================================
org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.getPoint():::ENTER
===========================================================================
org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.getPoint():::EXIT
this.point == orig(this.point)
this.point[] == orig(this.point[])
return[] elements one of { 0, 1 }
return[] one of { [0], [1] }
size(return[]) == 1
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy:::OBJECT
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.EmptyClusterStrategy(java.lang.String, int):::ENTER
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.EmptyClusterStrategy(java.lang.String, int):::EXIT
$hidden$1.toString == orig($hidden$1.toString)
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer:::OBJECT
this has only one value
this.random has only one value
this.emptyStrategy has only one value
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.LARGEST_VARIANCE has only one value
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.LARGEST_POINTS_NUMBER has only one value
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.FARTHEST_POINT has only one value
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.ERROR has only one value
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.$VALUES has only one value
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.$VALUES.getClass().getName() == org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy[].class
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.$VALUES[] contains no nulls and has only one value, of length 4
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.$VALUES[].getClass().getName() == [org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.EmptyClusterStrategy, org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.EmptyClusterStrategy, org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.EmptyClusterStrategy, org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.EmptyClusterStrategy]
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.$VALUES[].getClass().getName() elements == org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.EmptyClusterStrategy.class
size(org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.$VALUES[]) == 4
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.KMeansPlusPlusClusterer(java.util.Random):::ENTER
random has only one value
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.KMeansPlusPlusClusterer(java.util.Random):::EXIT
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.KMeansPlusPlusClusterer(java.util.Random, org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy):::ENTER
random has only one value
emptyStrategy has only one value
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.LARGEST_VARIANCE has only one value
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.LARGEST_POINTS_NUMBER has only one value
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.FARTHEST_POINT has only one value
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.ERROR has only one value
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.$VALUES has only one value
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.$VALUES.getClass().getName() == org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy[].class
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.$VALUES[] contains no nulls and has only one value, of length 4
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.$VALUES[].getClass().getName() == [org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.EmptyClusterStrategy, org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.EmptyClusterStrategy, org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.EmptyClusterStrategy, org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.EmptyClusterStrategy]
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.$VALUES[].getClass().getName() elements == org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.EmptyClusterStrategy.class
size(org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.$VALUES[]) == 4
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.KMeansPlusPlusClusterer(java.util.Random, org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy):::EXIT
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.LARGEST_VARIANCE == orig(org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.LARGEST_VARIANCE)
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.LARGEST_POINTS_NUMBER == orig(org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.LARGEST_POINTS_NUMBER)
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.FARTHEST_POINT == orig(org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.FARTHEST_POINT)
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.ERROR == orig(org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.ERROR)
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.$VALUES == orig(org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.$VALUES)
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.$VALUES.getClass().getName() == orig(org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.$VALUES.getClass().getName())
org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.$VALUES[] == orig(org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer$EmptyClusterStrategy.$VALUES[])
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest$CloseIntegerPoint:::OBJECT
this.euclideanPoint.point[] elements one of { 0, 1 }
this.euclideanPoint.point[] one of { [0], [1] }
org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest.this has only one value
size(this.euclideanPoint.point[]) == 1
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest$CloseIntegerPoint.CloseIntegerPoint(org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest, org.apache.commons.math.stat.clustering.EuclideanIntegerPoint):::ENTER
org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest.this has only one value
point.point[] elements one of { 0, 1 }
point.point[] one of { [0], [1] }
size(point.point[]) == 1
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest$CloseIntegerPoint.CloseIntegerPoint(org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest, org.apache.commons.math.stat.clustering.EuclideanIntegerPoint):::EXIT
org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest.this == orig(org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest.this)
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest$CloseIntegerPoint.distanceFrom(org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest$CloseIntegerPoint):::ENTER
p has only one value
p.euclideanPoint has only one value
p.euclideanPoint.point has only one value
p.euclideanPoint.point[] == [0]
p.euclideanPoint.point[] elements == 0
size(p.euclideanPoint.point[]) == 1
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest$CloseIntegerPoint.distanceFrom(org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest$CloseIntegerPoint):::EXIT
this.euclideanPoint == orig(this.euclideanPoint)
this.euclideanPoint.point == orig(this.euclideanPoint.point)
this.euclideanPoint.point[] == orig(this.euclideanPoint.point[])
org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest.this == orig(org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest.this)
p.euclideanPoint == orig(p.euclideanPoint)
p.euclideanPoint.point == orig(p.euclideanPoint.point)
p.euclideanPoint.point[] == orig(p.euclideanPoint.point[])
p.euclideanPoint has only one value
p.euclideanPoint.point has only one value
p.euclideanPoint.point[] == [0]
p.euclideanPoint.point[] elements == 0
return one of { 0.0, 0.001 }
size(p.euclideanPoint.point[]) == 1
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest$CloseIntegerPoint.equals(java.lang.Object):::ENTER
this has only one value
this.euclideanPoint has only one value
this.euclideanPoint.point has only one value
this.euclideanPoint.point[] == [0]
this.euclideanPoint.point[] elements == 0
o has only one value
o.getClass().getName() == org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest$CloseIntegerPoint.class
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest$CloseIntegerPoint.equals(java.lang.Object):::EXIT200
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest$CloseIntegerPoint.equals(java.lang.Object):::EXIT200;condition="return == true"
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest$CloseIntegerPoint.equals(java.lang.Object):::EXIT
this.euclideanPoint == orig(this.euclideanPoint)
this.euclideanPoint.point == orig(this.euclideanPoint.point)
this.euclideanPoint.point[] == orig(this.euclideanPoint.point[])
org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest.this == orig(org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest.this)
this.euclideanPoint has only one value
this.euclideanPoint.point has only one value
this.euclideanPoint.point[] == [0]
this.euclideanPoint.point[] elements == 0
return == true
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest$CloseIntegerPoint.equals(java.lang.Object):::EXIT;condition="return == true"
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest:::OBJECT
this has only one value
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest.KMeansPlusPlusClustererTest():::EXIT
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest.testSmallDistances():::ENTER
===========================================================================
org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest.testSmallDistances():::EXIT
===========================================================================
org.apache.commons.math.util.FastMath:::CLASS
===========================================================================
org.apache.commons.math.util.FastMath.buildSinCosTables():::ENTER
===========================================================================
org.apache.commons.math.util.FastMath.buildSinCosTables():::EXIT
===========================================================================
org.apache.commons.math.util.FastMath.expint(int, double[]):::ENTER
result has only one value
size(result[]) == 2
===========================================================================
org.apache.commons.math.util.FastMath.expint(int, double[]):::EXIT
===========================================================================
org.apache.commons.math.util.FastMath.quadMult(double[], double[], double[]):::ENTER
a[] sorted by >
b[] sorted by >
size(a[]) == 2
size(b[]) == 2
size(result[]) == 2
===========================================================================
org.apache.commons.math.util.FastMath.quadMult(double[], double[], double[]):::EXIT
a[] == orig(a[])
b[] == orig(b[])
a[] sorted by >
b[] sorted by >
===========================================================================
org.apache.commons.math.util.FastMath.resplit(double[]):::ENTER
size(a[]) == 2
===========================================================================
org.apache.commons.math.util.FastMath.resplit(double[]):::EXIT
===========================================================================
org.apache.commons.math.util.FastMath.slowCos(double, double[]):::ENTER
result has only one value
result[] sorted by >=
size(result[]) == 2
===========================================================================
org.apache.commons.math.util.FastMath.slowCos(double, double[]):::EXIT
result[] sorted by >
result[] > orig(result[]) (lexically)
result[] >= orig(result[]) (lexically)
===========================================================================
org.apache.commons.math.util.FastMath.slowLog(double):::ENTER
===========================================================================
org.apache.commons.math.util.FastMath.slowLog(double):::EXIT
return[] sorted by >=
size(return[]) == 2
===========================================================================
org.apache.commons.math.util.FastMath.slowSin(double, double[]):::ENTER
result has only one value
result[] sorted by >=
size(result[]) == 2
===========================================================================
org.apache.commons.math.util.FastMath.slowSin(double, double[]):::EXIT
result[] sorted by >=
result[] <= orig(result[]) (lexically)
===========================================================================
org.apache.commons.math.util.FastMath.slowexp(double, double[]):::ENTER
result has only one value
size(result[]) == 2
===========================================================================
org.apache.commons.math.util.FastMath.slowexp(double, double[]):::EXIT
result[] sorted by >
===========================================================================
org.apache.commons.math.util.FastMath.split(double, double[]):::ENTER
size(split[]) == 2
===========================================================================
org.apache.commons.math.util.FastMath.split(double, double[]):::EXIT
===========================================================================
org.apache.commons.math.util.FastMath.splitAdd(double[], double[], double[]):::ENTER
b[] elements <= 2.0
ans[] sorted by >=
size(a[]) == 2
size(b[]) == 2
size(ans[]) == 2
===========================================================================
org.apache.commons.math.util.FastMath.splitAdd(double[], double[], double[]):::EXIT
b[] == orig(b[])
b[] elements <= 2.0
===========================================================================
org.apache.commons.math.util.FastMath.splitMult(double[], double[], double[]):::ENTER
size(a[]) == 2
size(b[]) == 2
size(ans[]) == 2
===========================================================================
org.apache.commons.math.util.FastMath.splitMult(double[], double[], double[]):::EXIT
a[] == orig(a[])
b[] == orig(b[])
===========================================================================
org.apache.commons.math.util.FastMath.splitReciprocal(double[], double[]):::ENTER
result[] elements <= 1.0
size(in[]) == 2
size(result[]) == 2
===========================================================================
org.apache.commons.math.util.FastMath.splitReciprocal(double[], double[]):::EXIT
in[] == orig(in[])
===========================================================================
org.apache.commons.math.util.FastMath.sqrt(double):::ENTER
a one of { 0.0, 1.0 }
===========================================================================
org.apache.commons.math.util.FastMath.sqrt(double):::EXIT
return one of { 0.0, 1.0 }
