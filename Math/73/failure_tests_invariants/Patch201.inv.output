===========================================================================
org.apache.commons.math.ConvergingAlgorithmImpl:::OBJECT
this has only one value
this.getClass().getName() == org.apache.commons.math.analysis.solvers.BrentSolver.class
this.absoluteAccuracy == 1.0E-6
this.relativeAccuracy == 1.0E-14
this.maximalIterationCount == 100
this.defaultAbsoluteAccuracy == 1.0E-6
this.defaultRelativeAccuracy == 1.0E-14
this.defaultMaximalIterationCount == 100
this.iterationCount == 0
===========================================================================
org.apache.commons.math.ConvergingAlgorithmImpl.ConvergingAlgorithmImpl(int, double):::ENTER
defaultMaximalIterationCount == 100
defaultAbsoluteAccuracy == 1.0E-6
===========================================================================
org.apache.commons.math.ConvergingAlgorithmImpl.ConvergingAlgorithmImpl(int, double):::EXIT
===========================================================================
org.apache.commons.math.MathRuntimeException$4:::CLASS
===========================================================================
org.apache.commons.math.MathRuntimeException$4:::OBJECT
this.val$pattern.toString one of { "endpoints do not specify an interval: [{0}, {1}]", "function values at endpoints do not have different signs.  Endpoints: [{0}, {1}], Values: [{2}, {3}]" }
this.val$arguments.getClass().getName() == java.lang.Object[].class
this.val$arguments[].getClass().getName() elements == java.lang.Double.class
this.val$arguments[].getClass().getName() one of { [java.lang.Double, java.lang.Double], [java.lang.Double, java.lang.Double, java.lang.Double, java.lang.Double] }
size(this.val$arguments[]) one of { 2, 4 }
===========================================================================
org.apache.commons.math.MathRuntimeException$4.(java.lang.String, java.lang.Object[]):::ENTER
$hidden$1.toString one of { "endpoints do not specify an interval: [{0}, {1}]", "function values at endpoints do not have different signs.  Endpoints: [{0}, {1}], Values: [{2}, {3}]" }
$hidden$2.getClass().getName() == java.lang.Object[].class
size($hidden$2[]) one of { 2, 4 }
===========================================================================
org.apache.commons.math.MathRuntimeException$4.(java.lang.String, java.lang.Object[]):::EXIT
$hidden$1.toString == orig($hidden$1.toString)
$hidden$2[] == orig($hidden$2[])
$hidden$1.toString one of { "endpoints do not specify an interval: [{0}, {1}]", "function values at endpoints do not have different signs.  Endpoints: [{0}, {1}], Values: [{2}, {3}]" }
===========================================================================
org.apache.commons.math.MathRuntimeException:::CLASS
===========================================================================
org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(java.lang.String, java.lang.Object[]):::ENTER
pattern.toString one of { "endpoints do not specify an interval: [{0}, {1}]", "function values at endpoints do not have different signs.  Endpoints: [{0}, {1}], Values: [{2}, {3}]" }
arguments.getClass().getName() == java.lang.Object[].class
size(arguments[]) one of { 2, 4 }
===========================================================================
org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(java.lang.String, java.lang.Object[]):::EXIT
pattern.toString == orig(pattern.toString)
arguments[] == orig(arguments[])
pattern.toString one of { "endpoints do not specify an interval: [{0}, {1}]", "function values at endpoints do not have different signs.  Endpoints: [{0}, {1}], Values: [{2}, {3}]" }
===========================================================================
org.apache.commons.math.analysis.SinFunction:::OBJECT
this has only one value
===========================================================================
org.apache.commons.math.analysis.SinFunction.SinFunction():::EXIT
===========================================================================
org.apache.commons.math.analysis.SinFunction.value(double):::ENTER
x one of { 1.0, 1.2, 1.5 }
===========================================================================
org.apache.commons.math.analysis.SinFunction.value(double):::EXIT
return one of { 0.8414709848078965, 0.9320390859672263, 0.9974949866040544 }
===========================================================================
org.apache.commons.math.analysis.solvers.BrentSolver:::CLASS
org.apache.commons.math.analysis.solvers.BrentSolver.NON_BRACKETING_MESSAGE has only one value
org.apache.commons.math.analysis.solvers.BrentSolver.NON_BRACKETING_MESSAGE.toString == "function values at endpoints do not have different signs.  Endpoints: [{0}, {1}], Values: [{2}, {3}]"
===========================================================================
org.apache.commons.math.analysis.solvers.BrentSolver:::OBJECT
this has only one value
this.functionValueAccuracy == 1.0E-15
this.defaultFunctionValueAccuracy == 1.0E-15
this.resultComputed == false
this.result == 0.0
this.functionValue == 0.0
this.f == null
this.absoluteAccuracy == 1.0E-6
this.relativeAccuracy == 1.0E-14
this.maximalIterationCount == 100
this.defaultAbsoluteAccuracy == 1.0E-6
this.defaultRelativeAccuracy == 1.0E-14
this.defaultMaximalIterationCount == 100
this.iterationCount == 0
===========================================================================
org.apache.commons.math.analysis.solvers.BrentSolver.BrentSolver():::EXIT
===========================================================================
org.apache.commons.math.analysis.solvers.BrentSolverTest:::OBJECT
===========================================================================
org.apache.commons.math.analysis.solvers.BrentSolverTest.BrentSolverTest(java.lang.String):::ENTER
===========================================================================
org.apache.commons.math.analysis.solvers.BrentSolverTest.BrentSolverTest(java.lang.String):::EXIT
name.toString == orig(name.toString)
===========================================================================
org.apache.commons.math.analysis.solvers.BrentSolverTest.testBadEndpoints():::ENTER
this has only one value
===========================================================================
org.apache.commons.math.analysis.solvers.BrentSolverTest.testBadEndpoints():::EXIT
===========================================================================
org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:::OBJECT
this has only one value
this.getClass().getName() == org.apache.commons.math.analysis.solvers.BrentSolver.class
this.functionValueAccuracy == 1.0E-15
this.defaultFunctionValueAccuracy == 1.0E-15
this.resultComputed == false
this.result == 0.0
this.functionValue == 0.0
this.f == null
this.absoluteAccuracy == 1.0E-6
this.relativeAccuracy == 1.0E-14
this.maximalIterationCount == 100
this.defaultAbsoluteAccuracy == 1.0E-6
this.defaultRelativeAccuracy == 1.0E-14
this.defaultMaximalIterationCount == 100
this.iterationCount == 0
===========================================================================
org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.UnivariateRealSolverImpl(int, double):::ENTER
defaultMaximalIterationCount == 100
defaultAbsoluteAccuracy == 1.0E-6
===========================================================================
org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.UnivariateRealSolverImpl(int, double):::EXIT
===========================================================================
org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.clearResult():::ENTER
===========================================================================
org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.clearResult():::EXIT
this.functionValueAccuracy == orig(this.functionValueAccuracy)
this.defaultFunctionValueAccuracy == orig(this.defaultFunctionValueAccuracy)
this.resultComputed == orig(this.resultComputed)
this.result == orig(this.result)
this.functionValue == orig(this.functionValue)
this.f == orig(this.f)
this.absoluteAccuracy == orig(this.absoluteAccuracy)
this.relativeAccuracy == orig(this.relativeAccuracy)
this.maximalIterationCount == orig(this.maximalIterationCount)
this.defaultAbsoluteAccuracy == orig(this.defaultAbsoluteAccuracy)
this.defaultRelativeAccuracy == orig(this.defaultRelativeAccuracy)
this.defaultMaximalIterationCount == orig(this.defaultMaximalIterationCount)
this.iterationCount == orig(this.iterationCount)
===========================================================================
org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.isSequence(double, double, double):::ENTER
start == 1.0
mid == 1.2
end == 1.5
===========================================================================
org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.isSequence(double, double, double):::EXIT
this.functionValueAccuracy == orig(this.functionValueAccuracy)
this.defaultFunctionValueAccuracy == orig(this.defaultFunctionValueAccuracy)
this.resultComputed == orig(this.resultComputed)
this.result == orig(this.result)
this.functionValue == orig(this.functionValue)
this.f == orig(this.f)
this.absoluteAccuracy == orig(this.absoluteAccuracy)
this.relativeAccuracy == orig(this.relativeAccuracy)
this.maximalIterationCount == orig(this.maximalIterationCount)
this.defaultAbsoluteAccuracy == orig(this.defaultAbsoluteAccuracy)
this.defaultRelativeAccuracy == orig(this.defaultRelativeAccuracy)
this.defaultMaximalIterationCount == orig(this.defaultMaximalIterationCount)
this.iterationCount == orig(this.iterationCount)
return == true
===========================================================================
org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.isSequence(double, double, double):::EXIT;condition="return == true"
===========================================================================
org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.verifyInterval(double, double):::ENTER
lower == 1.0
upper == 1.5
===========================================================================
org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.verifyInterval(double, double):::EXIT
this.functionValueAccuracy == orig(this.functionValueAccuracy)
this.defaultFunctionValueAccuracy == orig(this.defaultFunctionValueAccuracy)
this.resultComputed == orig(this.resultComputed)
this.result == orig(this.result)
this.functionValue == orig(this.functionValue)
this.f == orig(this.f)
this.absoluteAccuracy == orig(this.absoluteAccuracy)
this.relativeAccuracy == orig(this.relativeAccuracy)
this.maximalIterationCount == orig(this.maximalIterationCount)
this.defaultAbsoluteAccuracy == orig(this.defaultAbsoluteAccuracy)
this.defaultRelativeAccuracy == orig(this.defaultRelativeAccuracy)
this.defaultMaximalIterationCount == orig(this.defaultMaximalIterationCount)
this.iterationCount == orig(this.iterationCount)
===========================================================================
org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.verifySequence(double, double, double):::ENTER
lower == 1.0
initial == 1.2
upper == 1.5
===========================================================================
org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.verifySequence(double, double, double):::EXIT
this.functionValueAccuracy == orig(this.functionValueAccuracy)
this.defaultFunctionValueAccuracy == orig(this.defaultFunctionValueAccuracy)
this.resultComputed == orig(this.resultComputed)
this.result == orig(this.result)
this.functionValue == orig(this.functionValue)
this.f == orig(this.f)
this.absoluteAccuracy == orig(this.absoluteAccuracy)
this.relativeAccuracy == orig(this.relativeAccuracy)
this.maximalIterationCount == orig(this.maximalIterationCount)
this.defaultAbsoluteAccuracy == orig(this.defaultAbsoluteAccuracy)
this.defaultRelativeAccuracy == orig(this.defaultRelativeAccuracy)
this.defaultMaximalIterationCount == orig(this.defaultMaximalIterationCount)
this.iterationCount == orig(this.iterationCount)
